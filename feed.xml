

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>/</id>
  <title>Krishnanand Sivaraj</title>
  <subtitle>Software, books and the world around me. Thoughts are my own.</subtitle>
  <updated>2021-05-09T15:16:23+08:00</updated>
  <author>
    <name>krishnanand_sivaraj</name>
    <uri>/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en-US"
    href="/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator>
  <rights> © 2021 krishnanand_sivaraj </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>Chapter 8 - Iterating and testing</title>
    <link href="/posts/iteration-and-testing/" rel="alternate" type="text/html" title="Chapter 8 - Iterating and testing" />
    <published>2021-05-08T23:15:00+08:00</published>
  
    <updated>2021-05-08T23:15:00+08:00</updated>
  
    <id>/posts/iteration-and-testing/</id>
    <content src="/posts/iteration-and-testing/" />
    <author>
      <name>Krishnanand Sivaraj</name>
    </author>

  
    
    <category term="Design" />
    
    <category term="Architecture" />
    
  

  
    <summary>
      





      Chapter 8 - Iterating and testing


  The first step in writing good software is to make sure your application works like the customer expects and wants it to.
  Customers don’t usually care about diagrams and lists.  They want to see your software actually do something.
  Use case driven development focuses on one scenario in a use case in your application at a time.
  In use case driven devel...
    </summary>
  

  </entry>

  
  <entry>
    <title>Chapter 7 - Design Principles</title>
    <link href="/posts/design-principles/" rel="alternate" type="text/html" title="Chapter 7 - Design Principles" />
    <published>2021-05-08T23:05:00+08:00</published>
  
    <updated>2021-05-08T23:05:00+08:00</updated>
  
    <id>/posts/design-principles/</id>
    <content src="/posts/design-principles/" />
    <author>
      <name>Krishnanand Sivaraj</name>
    </author>

  
    
    <category term="Design" />
    
    <category term="Architecture" />
    
  

  
    <summary>
      





      Chapter 7 : Design Principles


  The Open-Closed Principle keeps your software reusable, but still flexible, by keeping classes open for extension but closed for modification.
  With classes doing one single thing through the SRP, it is even easier to apply the OCP to your code.
  When you’re trying to determine if a method is the responsibility of a class, ask yourself, is it this class’s job...
    </summary>
  

  </entry>

  
  <entry>
    <title>Chapter 6 - Architecture</title>
    <link href="/posts/architecture/" rel="alternate" type="text/html" title="Chapter 6 - Architecture" />
    <published>2021-05-08T21:55:00+08:00</published>
  
    <updated>2021-05-08T21:55:00+08:00</updated>
  
    <id>/posts/architecture/</id>
    <content src="/posts/architecture/" />
    <author>
      <name>Krishnanand Sivaraj</name>
    </author>

  
    
    <category term="Design" />
    
    <category term="Architecture" />
    
  

  
    <summary>
      





      Chapter 6 : Architecture


  Architecture helps you turn all your diagrams, plans and feature lists into well-ordered application.
  The features in your system that are most important to your project are architecture significant.
  Focus on features that are essence of the system, that you’re unsure about meeting of, or unclear about how to implement first.
  Everything you do in architecture ...
    </summary>
  

  </entry>

  
  <entry>
    <title>Chapter 5 - Solving really big problem</title>
    <link href="/posts/solving-big-problems/" rel="alternate" type="text/html" title="Chapter 5 - Solving really big problem" />
    <published>2021-05-08T20:55:00+08:00</published>
  
    <updated>2021-05-08T20:55:00+08:00</updated>
  
    <id>/posts/solving-big-problems/</id>
    <content src="/posts/solving-big-problems/" />
    <author>
      <name>Krishnanand Sivaraj</name>
    </author>

  
    
    <category term="Design" />
    
    <category term="Architecture" />
    
  

  
    <summary>
      





      Chapter 5 : Solving really big problem


  You solve big problems the way you solve small problems.
  The best way to look at a big problem is to see it as lots of individual pieces of functionality.
  You can treat each of these problems as individual problem or solve and apply the things you already know.
  Commonality and variability
    
      commanity : figure out what the system is like
...
    </summary>
  

  </entry>

  
  <entry>
    <title>Chapter 3 - Requirements change</title>
    <link href="/posts/requirements-change-copy/" rel="alternate" type="text/html" title="Chapter 3 - Requirements change" />
    <published>2021-05-07T20:55:00+08:00</published>
  
    <updated>2021-05-07T20:55:00+08:00</updated>
  
    <id>/posts/requirements-change-copy/</id>
    <content src="/posts/requirements-change-copy/" />
    <author>
      <name>Krishnanand Sivaraj</name>
    </author>

  
    
    <category term="Design" />
    
    <category term="Architecture" />
    
  

  
    <summary>
      





      Chapter 3 : Requirements change



  A complete path through a usecase from the first step to the last is called a scenario.



  Most usecases have several different scenarios but they always share the same goal.



Summary / Takeaways


  Requirements will always change as a project progresses.
  When requirement changes, your system has to evolve to handle new requirements.
  When your syste...
    </summary>
  

  </entry>

</feed>


